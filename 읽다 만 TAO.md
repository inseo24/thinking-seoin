- TAO: Facebook’s Distributed Data Store for the Social Graph
    - 용어 정리
        - 캐시 유지 메시지 : cache maintenance message
        - 무효화 : invalidation
    - TAO : Facebook에서 사용하는 분산 데이터 저장소
        - 복잡한 소셜 그래프 데이터 처리를 위해 만들어짐
        - 객체와 관계 모델을 직접 구현하며, 복제, 일관성 유지, 캐싱 등을 고려해 설계됌
    - TAO는 기존 lookaside cache architecture의 몇 가지 근본적인 문제를 해결
        - 비효율적인 edge 목록
            - Edge lists는 key-value cache에 적합하지 않기 때문에, 쿼리는 항상 전체 edge list를 가져와야하며, 단일 edge에 대한 변경은 전체 목록을 다시 로드해야합니다.
            - 따라서 TAO는 복잡한 업데이트를 동시에 조율하기 위해 매우 복잡한 방식이 필요한 기본적인 리스트 지원이 아니라, 다른 방법을 사용합니다.
            - key-value 캐시는 edge 목록에 적합하지 않다. 쿼리는 항상 전체 edge 목록을 가져와야 하고 단일 edge를 변경하려면 전체 목록을 다시 불러와야 한다.
        - 분산된 제어 로직
            - lookaside cache 아키텍처에선 제어 로직이 서로 통신하지 않는 client에서 실행된다. 이로 인해 장애가 증가함
            - 객체와 관계의 경우 고정된 API를 사용해 제어 로직을 캐시 자체로 이동시켜 문제를 효율적으로 해결할 수 있다.
            - 고정된 API를 사용해 캐시 관리와 관련된 로직을 캐시 시스템 내부로 통합한다. → 분산된 클라이언트가 실행되는 제어 로직이 아니라, 캐시 시스템이 직접 데이터 관리와 관련 로직을 처리하게 됨
        - 비용이 많이 드는 읽기 후 쓰기 일관성
            - Facebook은 MySQL에 비동기 Master/Slave 복제를 사용함
            - 여러 데이터 센터에서 캐시를 사용하다 보니 복제본을 사용하는 데이터 센터의 캐시에 문제가 발생할 수 있다. 쓰기는 마스터로 전달되지만, 로컬 복제본이 반영되기까지 일정한 시간이 걸린다.
            - 이 문제를 해결하기 위해 TAO에서는 데이터 모델을 객체와 Relationship으로 제한하고, 쓰기 시점에 복제본의 캐시를 업데이트한 후 Graph Semantic을 사용해 동시 업데이트에서 cache 유지 관리 메시지를 해석해, 리전 간 통신 없이도 캐시를 공유하는 모든 클라이언트에 대해 읽기 후 쓰기 일관성을 제공할 수 있도록 했다.
                - 즉, 사실상 쓰기 작업을 수행할 때 자동으로 관련 캐시 항목을 무효화시키는 캐시 동기화 메커니즘을 사용함(Cache Invalidation 문제 해결)
            - remote markers는 오래된 key를 찾아내 해당 키에 대한 읽기를 Master 리전으로 전달함
        - 논문에 소개된 건 위에꺼가 다고, 이건 좀 더 찾아본 내용
            - Cache Coherence
                - 선형적으로 확장 가능한 알고리즘을 사용해 모든 캐시 레이어에 동일한 데이터를 제공해 캐시 일관성을 보장한다.
                - 데이터의 일부만 업데이트 하는 것이 아니라 전체 데이터를 교체하는 방식으로 캐시 업데이트를 수행해 캐시 일관성 강화
            - Cache Miss Penalty
                - 지연 시간을 줄이기 위한 최적화 기법 사용
                    - 다단계 캐시 구조를 사용해 로컬 및 원격 캐시 간의 지연 시간을 최소화함
                    - 로컬 캐시에서 찾지 못할 경우, 원격 캐시를 조회해 캐시 미스로 인한 DB 접근 횟수를 줄임
                    - 점진적으로 더 넓은 범위의 캐시 레이어를 확인하는 방식으로 캐시 미스 문제를 최소화함
            - Cache Size Limitations
                - 동적으로 캐시 크기를 조정하는 기능을 사용함
                - 시스템이 인기 있는 데이터와 그렇지 않는 데이터 간의 균형을 찾아 캐시 크기를 조절함
                - 데이터 액세스 패턴을 분석해 캐시 내 데이터의 우선순위를 결정하고, 이거에 따라 캐시에서 데이터를 추가하거나 제거하는 전략을 적용한다.
    - Objects & Associations
        - Objects : 타입화된 노드
            - 64bit 정수 id로 식별
            - 오브젝트 타입(otype)은 key-value 쌍으로 이뤄진 데이터를 포함
        - Associations(연관) : 오브젝트 간 타입화된 방향성 있는 엣지
            - 출발하는 오브젝트(id1), Association Type(atype) 및 대상 오브젝트(id2)로 식별
            - 하나의 타입에 대해 최대 1개의 연결이 존재할 수 있음
            - 32bit 시간 필드 포함
        - TAO에서는 Action을 오브젝트 또는 연관으로 인코딩될 수 있다.
            - 예를 들어, 서인의 코멘트와 인서의 ‘좋아요’는 모두 사용자가 수행한 액션이지만, 코멘트만 새로운 오브젝트를 만들어낸다. 연관은 최대 1번 일어날 수 있는 액션을 자연스럽게 모델링하며, 이벤트 초대 수락과 같은 상태의 전이를 기록한다. 반복 가능한 액션을 오브젝트로 더 잘 나타낼 수 있다.
        - 연관은 방향성이 있지만, 반대 엣지와 결합된 경우가 많다. 즉, 양방향으로 연관이 생길 수도 있다.
            - Comment는 Check-in Object로 traverse하지 않기 때문에 이 경우 반대 엣지가 필요하지 않다.
            
    - Object, Association, Association Query API
        - TAO는 Objects와 Associations의 두 가지 유형을 가지는 API를 제공합니다.
            - 모든 객체와 연관성에는 키-값 쌍의 데이터가 포함될 수 있으며, 유형마다 스키마가 있어 가능한 키, 값 유형 및 기본값을 나열합니다.
        - TAO의 Object API
            - 새 개체 및 ID를 할당하고 ID와 관련된 개체를 검색, 업데이트 또는 삭제하는 작업을 제공합니다.
            - 일부 필드의 하위 집합에 대한 업데이트 작업이 가능합니다.
        - TAO의 Association API는 연결 작업을 수행합니다.
            - 대부분의 연결은 양방향입니다. 따라서 양방향 연결은 두 개의 별도 연관성으로 모델링됩니다.
            - 연결 유형은 반대 유형으로 구성할 수 있으므로 생성, 업데이트 및 삭제가 자동으로 반대 연관성 작업과 결합됩니다.
            - 대칭 양방향 유형은 자체 반대를 나타냅니다.
            - 연관성 작업에는 다음이 포함됩니다.
                - assoc add(id1, atype, id2, time, (k→v)*) : 연관성 (id1, atype,id2) 및 정의된 경우 그 반대 연관성 (id1, inv(atype), id2)를 추가 또는 덮어씁니다.
                - assoc delete(id1, atype, id2) : 연관성 (id1, atype, id2)과 그 반대를 삭제합니다.
                - assoc change type(id1, atype, id2, newtype) : (id1, atype, id2)를 (id1, newtype, id2)로 변경합니다.
        - TAO의 Association Query API
            - 특정 객체에 대한 특정 유형의 정보를 검색하는 경우 시작 지점으로부터 연관성 목록을 탐색합니다.
            - 연관성 목록은 특정 id1 및 atype의 모든 연관성을 시간 순서대로 나열합니다.
            - 이러한 연관성 목록은 연관성 쿼리를 개선하기 위해 캐시에 저장됩니다.
            - 그러나, 이러한 Association list에서의 조회는 대규모 데이타에서는 매우 느릴 수 있습니다. 대신, TAO는 일정 시간 동안 변화가 없는(Stable) Association list를 별도의 Caching을 통해 효율적으로 저장하여, 빠르게 조회할 수 있도록 합니다. 이를 Stable Range라고 하며, assoc get()과 유사한 방식으로 쿼리를 수행합니다.
    - TAO Architecture
        - Storage Layer
            - MySQL DB를 사용해 객체와 연결을 영구적으로 저장
            - TAO API는 몇 가지 간단한 SQL 쿼리에 매핑함
            - 데이터는 논리적인 샤드로 분할함. 각 샤드는 논리적인 데이터베이스에 포함된다.
            - DB 서버는 하나 이상의 샤드에 대해 책임을 진다.
            - 기본적으로 모든 객체 타입은 하나의 테이블에 저장되고, 모든 연결 타입은 다른 테이블에 저장이 된다.
            - 각 객체 ID에는 호스팅 샤드를 식별하는 임베디드 샤드 ID가 포함된다.
            - 개체는 전체 수명 동안 샤드에 바인딩된다.
            - 연결은 id1의 샤드에 저장되어 연결 쿼리를 단일 서버에서 처리 할 수 있다.
            - 두 개의 ID가 서로 다른 서버에 매핑될 가능성은 생성 시 명시적으로 콜로케이트되지 않는 한 낮다.
                - 샤드 : 논리적인 데이터 조각.
                - Colocation : 여러 개의 서버를 물리적으로 가깝게 배치해, 서로 다른 서버 간의 네트워크 지연을 최소화하고 데이터 처리 속도를 향상시키는 방법. 서버 간 데이터 전송 속도가 빨라져 응답 시간이 단축되고 처리량이 높아짐
        - Cache Layer
            - 클라이언트의 모든 통신을 처리하고 모든 TAO 요청에 대한 API를 구현
            - 여러 개의 캐시 서버로 구성된다.
            - 각 요청은 샤딩 스키마를 사용해 단일 캐시 서버에 매핑된다.
            - 이 스키마는 캐시 서버가 어떤 요청을 처리할지 결정하며, 캐시 서버 수와 균형을 맞추기 위해 조정할 수 있다.
            - 클라이언트는 직접 적절한 캐시 서버에 요청을 보내며, 이 서버는 읽기 또는 쓰기 작업을 완료하는 책임이 있다. 캐시 미스 및 쓰기 요청의 경우 서버는 다른 캐시 또는 데이터베이스에 연락한다.
            - TAO 인메모리 캐시에는 객체, 연결 목록 및 연결 수가 포함된다. LRU 정책을 사용해 필요할 때 캐시를 채우고 항목을 제거한다.
            - 캐시 서버는 내용의 semantic을 이해해, 이전에 처리되지 않은 정확한 쿼리가 아니더라도 쿼리를 처리할 수 있다. 예를 들어, 캐시된 0 카운트는 범위 쿼리를 대답하는데 충분함
                - 샤딩 스키마(Sharding Schema) : 분산 시스템에서 데이터를 분산하는 방식을 결정하는 구조. 즉, 데이터를 어떻게 분할하고, 어떤 기준으로 분산시킬지 정의하는 계획
                    - 데이터 특성, 분산 시스템의 용량과 성능, 보안 등 여러가지 요소를 고려해야 한다.
                    - 예를 들어, 데이터 특성에 따라 사용자 ID나 지역 정보를 기준으로 데이터를 샤딩할 수 있고, 성능을 높이기 위해 데이터 양이 적은 샤드를 병렬로 처리할 수 있다.
            - 역관계를 가진 연관에 대한 쓰기 작업은 2개의 샤드를 포함할 수 있다. 즉, 순방향 엣지가 id1을 위한 샤드에 저장되고 역엣지가 id2를 위한 샤드에 저장된다.
            - 클라이언트로부터 쿼리를 받은 티어 멤버는 id2를 호스팅하는 멤버에게 RPC 호출을 발행하고, 이 멤버는 역관계를 만들기 위해 데이터베이스를 call한다. 역쓰기가 완료되면 캐싱 서버는 id1에 대한 DB 쓰기를 pub한다.
            - TAO는 2개의 업데이트 사이에서 원자성을 제공하지 않는다. 실패가 발생하면 역관계가 없는 순방향이 존재할 수 있다. 이런 불완전한 연관은 비동기적인 작업으로 복구되도록 예약된다.
        - Client Communication Stack
            - Facebook 페이지를 렌더링하는 동안 수백 개의 객체와 연결이 쿼리될 수 있는데, 이는 짧은 시간 내에 많은 캐시 서버와의 통신이 필요하다.
            - 결과적으로 발생하는 all-to-all 통신의 문제는 우리의 메모리 캐시 풀에서 마주쳤던 문제와 유사하다. TAO와 memcache는 대부분의 클라이언트 스택을 공유한다.
                - 메모리 캐시 풀에서의 문제는, 많은 수의 객체와 연결이 한 번에 조회될 때, 짧은 시간 내에 많은 수의 캐시 서버와 통신이 필요하다는 점이다. 이로 인해 all-to-all 통신 문제 발생하는데 이는 TAO에서도 마찬가지다.
                - 클라이언트 스택을 공유한다는건, TAO와 memcache가 클라이언트-서버 구조를 공유한다는 의미다. 즐, 클라이언트는 TAO와 memcache 모두에서 동일한 방식으로 서버에 연결하고, 쿼리를 보내고, 응답을 받음
            - TAO 요청의 대기시간은 memcache의 요청 대기 시간보다 훨씬 높을 수 있다. TAO 요청이 DB 접근이 있을 수 있기 때문이다.
            - 따라서 멀리플렉싱된 연결에서 head-of-line blocking을 피하려면, out-of-order response 프로토콜을 사용한다.
                - head-of-line blocking : 네트워크에서 패킷이 도착하는 순서와 관계없이 FIFO로 처리되는 현상. 즉, 하나의 패킷이 지연되면 그 다음에 도착하는 패킷들도 모두 대기해야 하는 현상
                - out-of-order response protocol : 네트워크에서 패킷이 도착하는 순서와 관계 없이 각각의 패킷이 도착하는대로 처리하는 방식. head-of-line blocking을 피할 수 있어 병목 현상을 줄이고 응답시간을 단축시킬 수 있다. 예를 들어, HTTP/2, SPDY가 있음
        - Leaders and Followers
            - 최대 티어 크기를 제한하면서 서버를 추가하기 위해 캐시를 2단계로 분리함 : leader tier, multiple follwer tiers
            - Leader 티어에는 DB당 하나의 캐시 코디네이터가 있으며, 각 TAO 쿼리에 대한 응답을 생성하기 위해 스토리지 계층에서 읽고 쓰기를 처리한다.
            - Follower 티어는 읽기 미스와 쓰기를 Leader로 전달한다.
            - 클라이언트는 가장 가까운 Follower 티어와 직접 통신하며, 이 Follwer 가 사용 불가능한 경우 다른 인접한 Follower 티어 접근함
                - TAO의 장점 중 일부는 DB당 하나의 단일 캐시 코디네이터를 가지는데 의존하기 때문에, 이 분한을 한 리전에서 코디네이터를 단일 티어로 유지할 수 있도록 한다.
                - 각 티어는 모든 TAO 쿼리에 응답할 수 있는 일련의 캐시 서버를 포함한다.
                - 즉, 시스템의 모든 샤드는 각각 하나의 캐시 서버에 매핑된다.
            - 각 샤드는 하나의 리더에 의해 호스팅되며 샤드에 대한 모든 쓰기는 해당 리더를 통해 수행되므로 자연스럽게 일관성이 유지된다.
            - 그러나 Follower는 다른 Follower 티어에서 수행된 업데이트에 대해 명시적으로 알림을 받아야 한다. 리더에서는 캐시 유지 메시지를 비동기적으로 팔로워에게 전송해 이벤트적 일관성을 제공한다.
            - 리더의 객체 업데이트는 각 대응하는 팔로워에게 무효화 메시지를 인큐하게 된다. 이 때, 쓰기를 수행한 팔로워는 리더에게 응답을 받으면 동기적으로 업데이트하게 된다.
                - 캐시 유지 메시지에 있는 버전 번호를 사용해 나중에 도착한 메시지는 무시할 수 있다.
            - TAO는 연속적인 Association 목록의 접두사만 캐시하기 때문에, Association을 무효화하는 경우 많은 엣지가 잘려나갈 수 있다. 따라서 리더는 팔로워가 캐시한 Association을 업데이트하도록 refill 메시지를 보내 이 문제를 해결한다.
                - Follower가 Association을 캐시하고 있으면 refill 요청이 Leader에 대한 쿼리를 트리거해 Follwer의 Assocation 목록을 업데이트한다.
                - 여러 Follower에서 동시에 도착하는 쓰기를 Leader가 직렬화하며, 이를 통해 한 번에 처리할 수 있는 최대 쿼리 수를 제한하여 DB에서 Thundering Herds 문제를 방지한다.
        - Scaling Geographically
            - multi-region  TAO Config를 통해 지역 간 확장을 지원한다. 이를 위해 각 지역에서는 하나의 완전한 copy를 유지해야 한다.
            - 이 때, follower들은 local region의 leader tier로 read misses와 writes를 전달한다.
            - 리더는 마스터든 슬레이브든 해당 리전의 데이터베이스에 대해 쿼리를 보내게 된다. 그러나 쓰기는 로컬 리더에서 마스터 디비를 갖고 있는 리전의 리더로 전달된다. 이를 통해 read latency는 리전 간 latency와 독립적이게 된다.
            - 마스터 리전은 각 샤드별로 별도로 제어되며, DB 장애 복구를 위해 자동으로 전환된다. 전환 중 실패한 쓰기는 클라이언트에게 실패했다는 응답을 보내며, 다시 시도하지 않는다. 하나의 캐시에서 여러 샤드를 호스팅하기 때문에, 서버는 동시에 마스터와 슬레이브가 될 수 있다.
                - 모든 마스터 디비를 하나의 지역에 위치시키는 것을 선호하기 때문에, 다른 지역에서 inverse assocation이 마스터화되는 경우, TAO는 inverse write를 전달하기 위해 한 번의 지역간 리전 link를 탐색해야 한다.
            - TAO에서는 invalidation과 refill 메시지를 데이터베이스 replication stream에 포함시켜 전송한다. 이 메시지들은 트랜잭션이 slave db로 복제된 직후에 로컬에 전달된다. 이전에 전송되는 것은 cache inconsistency 를 발생시킬 수 있다. TAO와 memcached에서 invalidations와 refills를 전달하기 위해 같은 pipeline을 사용한다.
            - 만약 forwarded write가 성공하면, local leader는 asynchronous replication stream에 의해 아직 업데이트되지 않은 local slave database와 달리 새로운 값으로 cache를 업데이트합니다. 이 경우, followers는 write가 성공하면 하나의 invalidate 또는 refill을 받게 되며, 해당 write의 transaction이 local slave database로 복제될 때 추가적인 invalidate 또는 refill을 받게 된다.
            - TAO의 master/slave 디자인은 모든 읽기를 단일 지역에서 처리할 수 있도록 보장하며, 클라이언트에게 stale data를 반환할 수도 있다. 사용자가 동일한 follower tier를 일관되게 쿼리하는 경우, 사용자는 일반적으로 TAO 상태의 일관성을 유지할 수 있다.
    - Implementation
        - TAO 서버들이 대용량 데이터 및 쿼리 요청을 처리하기 위해 어떤 최적화를 했는지
        - Caching Servers
            - 클라이언트와 DB 사이 중개 역할을 하며, 객체와 관계를 적극적으로 캐싱해 빠른 읽기 성능을 제공한다.
            - 메모리 관리는 Facebook에서 사용하는 커스텀된 memcached를 기반으로 한다.
            - TAO는 동일한 크기의 아이템 슬랩을 관리하는 slab allocator를 갖고, thread-safe hash table, 동일한 크기의 아이템 간의 LRU eviction, 동적 슬랩 리밸런서(dynamic slab rebalancer) 등의 기능을 제공한다
            - 슬랩 아이템은은 노드(node)나 엣지 리스트(edge list)를 하나만 보유할 수 있다.
            - 또한, 객체의 타입에 따라 메모리 공간을 구분하여 할당하므로, 중요한 객체나 데이터의 유효기간을 더 길게 유지하거나, 사용빈도가 적은 객체나 데이터를 더 빠르게 삭제할 수 있다.
            - 아레나라고 하는 메모리를 파티셔닝하는 것을 캐시 메모리 관리 방식으로 사용한다. 사용 가능한 RAM을 데이터 유형에 따라 분할해 관리한다. 중요한 데이터는 캐시 수명을 연장하고, 캐시를 잘 유지하는 데이터와 그렇지 않은 데이터를 분리해 관리한다.
            - 현재는 이 아레나를 수동으로 구성하지만, 앞으로 자동으로 아레나의 크기를 조정해 TAO의 캐시 히트율을 개선하는게 가능해질 것이다.
            - 작은 고정 크기 항목(예: 연관성 수)의 경우, 메인 해시 테이블의 버킷 항목에 대한 포인터의 메모리 오버헤드가 크다. 이런 항목들은 포인터 없이 직접 매핑되는 8-way associative cache를 사용해 별도로 저장한다.
            - 각 버킷 내의 LRU 순서는 항목을 아래로 슬라이딩해 추적한다. 이런 최적화를 통해 시스템 구성 당 약 20% 더 많은 아이템을 캐시할 수 있다.
            - 또한, 활성 atype마다 16비트 값을 매핑하는 테이블을 추가해 (id1, atype)를 32비트 수로 매핑할 수 있고, negative item은 (id1, atype)에 대한 id2의 결여를 기록해 10바이트만 사용함.
        - MySQL Mapping
            - TAO에서는 객체와 관계를 샤드(shard)라는 작은 조각으로 나누어 MySQL 데이터베이스에 저장함 이때 객체의 모든 필드는 하나의 "data" 열에 직렬화되어 저장된다.
            - 이런 방식을 통해 서로 다른 유형의 객체를 동일한 테이블에 저장할 수 있다. 하지만 별도의 데이터 관리 정책이 필요한 객체는 별도의 테이블에 저장된다.
            - 관계도 객체와 유사하게 저장되며, id1, atype 및 시간을 기반으로 한 추가 인덱스가 생성함.
            - SELECT COUNT 쿼리를 방지하기 위해 관계의 수는 별도의 테이블에 저장된다.
            - 이를 통해 TAO는 대용량 데이터를 빠르게 저장하고 쿼리할 수 있다.
        - Cache Sharding and Hot Spots
            - TAO는 consistent hashing을 사용하여 캐시 서버에 shard를 매핑한다.
            - 하지만 이러한 랜덤한 shard 할당은 일부 팔로워가 다른 팔로워보다 더 많은 요청 부하를 지게 할 수 있다.
            - 따라서 TAO는 shard cloning을 사용하여 팔로워 간에 부하를 균형있게 분산시킨다.
            - 이를 위해 하나의 shard를 다수의 팔로워가 복제하게 되고, 이 shard에 대한 일관성 관리 메시지는 해당 shard를 호스팅하는 모든 팔로워에게 전송된다.
            - TAO의 작업 부하 중 인기 있는 오브젝트는 다른 오브젝트보다 몇 배 더 자주 쿼리될 수 있다.
            - 이러한 경우, cloning은 여러 팔로워간의 부하를 분산시키지만, 이러한 오브젝트를 작은 클라이언트 측 캐시에 넣는 것이 유용하다.
            - 따라서 팔로워가 핫한 아이템에 대한 쿼리 응답을 제공하면, 해당 데이터와 버전의 접근률이 포함된다.
            - 만약 접근률이 일정 임계치를 초과한다면, TAO 클라이언트는 데이터와 버전을 캐시에 저장하고 이후에는 쿼리에서 버전 번호를 포함해서 팔로워가 이전 버전 이후에 데이터가 변경되지 않았다면 응답에서 데이터를 생략할 수 있다.
            - 이러한 접근률은 너무 많은 요청이 들어오는 핫한 오브젝트에 대한 클라이언트 요청 제한에 사용될 수 있다.
        - High-Degree Objects
            - 많은 객체들은 하나의 atype에서 6,000개 이상의 연관관계를 가지고 있어서, TAO는 전체 연관관계 목록을 캐시하지 않는다.
            - 또한 assoc get 쿼리 중에는 결과가 없는 경우가 자주 있다. (지정된 id1과 id2 사이에 엣지가 없는 경우)
            - 그러나 고차원 객체의 경우 쿼리가 항상 데이터베이스로 전송된다. 왜냐하면 캐시되지 않은 연관관계 목록의 끝에 쿼리된 id2가 있을 수 있기 때문
            - 이러한 효율성 문제를 해결하기 위해, 문제 쿼리를 발생시키는 클라이언트 코드를 수정하여 해결할 수 있다.
            - 다른 방법은 연관관계 수를 사용하여 쿼리 방향을 선택하는 것이다.
            - 또는 양 끝이 고차원 노드인 경우, 애플리케이션의 도메인 지식을 활용하여 캐시 가능성을 개선할 수도 있다.
            - 많은 연관관계는 생성 시간으로 시간 필드를 설정하며, 많은 객체는 생성 시간을 필드로 포함한다.
                - 노드로의 엣지는 노드가 생성된 후에만 만들 수 있으므로, 객체의 생성 시간보다 크거나 같은 시간을 가진 연관관계에 대해서만 id2 검색을 제한할 수 있다.
                - 캐시된 객체보다 오래된 엣지가 존재하는 한, 이 쿼리는 TAO 팔로워에서 직접 응답할 수 있다.
    - Consistency and Fault Tolerance
        - Consistency
            - 보통 객체와 연관관계는 최종적인 일관성이 유지된다.(eventually consistent)
            - 쓰기 작업 후 모든 티어로의 무효화(invalidation) 또는 refill이 최종적인 전달을 보장한다.
            - 외부 입력이 안정되는 충분한 시간이 지나면 TAO의 모든 데이터 사본은 일관성이 있고 모든 객체와 연관관계에 대한 모든 쓰기 작업을 반영한다.
            - 복제 지연(replication lag)은 일반적으로 1초 미만이다.
            - 일반적인 작업에서(요청에서 최대 1개의 실패) TAO는 단일 티어에서 쓰기 후 읽기 일관성(read-after-write consistency)을 제공한다.
            - TAO는 마스터 리더가 성공적으로 쓰기를 완료하면 로컬로 작성된 값을 캐시와 동기화하여 변경 내용(changeset)을 반환함으로써 동기화를 제공한다.
            - 이 변경 내용은 슬레이브 리더(있는 경우)를 통해 쓰기 쿼리의 원래 위치인 팔로어 티어로 전파된다.
            - 연관관계의 역 타입이 구성된 경우 해당 유형의 연관관계에 대한 쓰기는 id1과 id2의 샤드 모두에 영향을 미칠 수 있다.
            - 이러한 경우 마스터 리더가 반환하는 변경 내용에는 두 개의 업데이트가 포함되며, 슬레이브 리더(있는 경우) 및 쓰기를 전달한 팔로어는 각자의 티어에서 id2의 샤드로 변경 내용을 보내야 한다.
            - 팔로워의 캐시 내용이 stale일 경우 변경되어야 하는 세트(chageset)를 안전하게 적용할 수 없다. 이를 위해 persistence 와 캐시에 모두 존재하는 버전 번호를 사용해 대부분의 경우에 race condition을 해결한다.
            - 각 업데이트마다 버전 번호가 증가하므로 팔로워는 변경 세트가 이전 값보다 stale하다는 것을 나타낼 때 로컬 데이터 사본을 안전하게 무효화할 수 있다. 버전 번호는 TAO 클라이언트에게 노출되지 않는다. 슬레이브 리전에서 이 체계는 캐시 제거와 저장소 서버 변경 전파 사이의 드문 경합 상태에 취약하다. 슬레이브 리전에서는 이 스키마가 캐시에서 이전 값과 다를 경우 해당 데이터읠 로컬 copy를 안전하게 무효화할 수 있다.
            - TAO는 critical read를 표시해 마스터 영역으로 프록시될 수 있도록 하므로 인증 프로세스에서 replication lag가 무효화된 자격 증명을 사용하지 않도록 할 수 있다.
        - Failure Detection and Handling
            - Database Failure
                - 데이터베이스가 충돌하거나 유지 보수를 위해 오프라인 상태이거나 마스터 데이터베이스에서 복제 중인 경우 전역 구성에서 데이터베이스가 다운된다.
                - 마스터 데이터베이스가 다운되면 그 중 하나의 슬레이브가 자동으로 새로운 마스터가 된다.
                - 리전의 슬레이브 데이터베이스가 다운되면 캐시 미스는 데이터베이스 마스터를 호스팅하는 지역의 TAO 리더로 리디렉션된다. 하지만 캐시 일관성 메시지는 데이터베이스의 복제 스트림에 내장되어 있으므로 기본 메커니즘으로 전달할 수 없다. 슬레이브 데이터베이스가 다운되어 있는 동안 마스터 데이터베이스에서 추가적인 binlog tailer가 실행되며, refill 및 invalidate는 리전 간에 전달다. 슬레이브 데이터베이스가 다시 가동되면 장애에서의 무효화 및 refill 메시지가 다시 전달된다.
            - Leader failures
                - 리더 캐시 서버가 실패하면, 팔로워들은 자동으로 읽기와 쓰기 요청을 다른 서버로 라우팅된다.
                - 팔로워들은 읽기 미스를 데이터베이스에 직접 라우팅하지만 쓰기 요청은 실패한 리더 대신 랜덤한 서버로 라우팅된다.
                - 대체 리더는 쓰기와 역 관계 수정, 팔로워들에게 무효화 메시지를 보내는 등 관련된 작업을 수행한다. 또한 비동기 무효화 메시지를 원래의 리더에게 보내서 일관성을 복원한다.
                - 이런 비동기 무효화 메시지는 조정 노드에 기록되며, 복구될 때까지 복제 스트림에 삽입되어 대기한다.
                - 리더가 일부분만 사용 가능한 경우, 팔로워들은 리더의 일관성이 복원될 때까지 오래된 값을 볼 수 있다.
            - Refill and invalidation failures
                - TAO는 refill과 invalidation 메시지를 비동기적으로 전송한다. 만약 follower가 도달할 수 없는 경우, leader는 이후 전송을 위해 메시지를 디스크에 큐에 저장한다.
                - 영구적인 leader 장애로 인해 이 메시지가 손실된 경우 follower는 오래된 데이터로 남을 수 있다.
                - 이 문제는 shard id에서 모든 객체와 연결을 무효화하는 대량 무효화 작업으로 해결된다. 실패한 leader 를 대체한 후, 해당 leader에 매핑되는 모든 shard를 무효화하여 consistency를 복원해야 한다.
            - Follower failures
                - TAO의 팔로워가 실패하는 경우, 다른 티어의 팔로워가 실패한 호스트의 샤드 책임을 공유한다.
                - 각 TAO 클라이언트에 기본 및 백업 팔로워 티어를 구성한다. 일반적으로 요청은 기본 티어에만 보내진다.
                - 특정 요청에 대해 해당하는 서버가 시간 초과로 인해 다운되면 해당 요청은 대신 백업 티어의 해당 서버로 전송된다.
                - 실패 요청은 해당 샤드를 호스팅하는 서버에 전송되므로 완전히 캐시 가능하며 추가 일관성 작업이 필요하지 않다.
                - 클라이언트에서 읽기 및 쓰기 요청이 동일하게 실패된다.
                - 다른 티어 간의 장애 조치는 쓰기의 refill 또는 invalidate가 이루어지기 전에 읽기가 장애 조치 대상에 도달할 수 있으므로 읽기-쓰기 일관성이 위배될 수 있음을 유의해야 한다.