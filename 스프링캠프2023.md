### 스프링캠프 들으면서 생각한 것 정리


- 한 번 공부 해볼 것
    - Micrometer https://micrometer.io/docs/tracing#_purpose 
        - 코틀린으로 하기
    - TSID(Time-Sorted Unique Identifiers)


- 최근 고민 : 새로운 프로젝트에 들어온 사람들에게 어떻게 가이드를 할 것인가?
    - 코드 베이스가 x명이 하기에는 많은 양은 아님
    - 복잡도 및 코드 양이 가장 높은 것이 AController 이며 그 다음이 B, C/D 순임
    - 나의 경우 B를 맡아서 작업 했고, 그 뒤에 작업한 C/D Controller에 대해서는 어느 정도 이해하고 있는 상황. 하지만 A 대한 이해와 그 외 Config 쪽에 대한 이해가 부족함

- 해결책 : 아키텍처 개선을 제안하자
    - 퇴사한 전임자 코드, 현재 담당자 코드, 내 코드가 섞여 상당히 체계가 없는 상태
    - 즉, 공통된 원칙 부재함 <- 이 부분에 대한 협의가 필요함
        - 예를 들어, 캐시를 조회 한다면 캐시는 어디 레이어에서 조회하도록 일관성 있게 유지를 할 것인지?
            - 서버에서 사용하는 외부 의존성
        - 최근 validation 처리를 하면서 느낀 게, NullPointerException 체크가 더 꼼꼼하게 되어야 할 것 같음.
        - 책임과 역할을 잘 구분할 것
        - 에러 코드가 있다면, 엥간해서 각기 다른 로직에서 이름이 같다는 이유로 해당 에러 코드를 쓰고 있지 않은지 체크 필요
   
    <details>
        <summary>아키텍처는 어떻게 할 것인지?</summary>

    - DDD, port & adapter, event driven 구조
    - 구성에서 고민이 필요한 것
        - 패키지 구성
            - Application
            - Domain
            - Infra
                - Adapter
                - Api
                - Events
                - persistence
        - 이벤트 구성
            - 이 부분은 이미 되어 있는 것이 있음
            - 다만, 문서화가 필요할 듯 싶음(다른 것도 마찬가지)
        - 도메인 구성
            - 고민할 것은 anemic or rich?
            - Getter & Setter 정도만 있는 anemic 도메인을 어떻게 할 것인지?
            - 단순히 DB schema가 아닌 domain modeling이 필요
                - 역할과 책임에 대해 고민할 것
            - 역할을 정했다면, 역할에 맞는 타입을 구성할 것
                - 추상화된 스키마 구성이 필요함 (schema.org)
    - 의존성의 방향을 정리할 것
        - 도메인에선 인프라에 대한 의존성이 있어선 안 된다.
            - 예를 들어, 페이징을 위해 해당 프로퍼티를 도메인에 넣으면 안 됌
            - 요청에 대해 책임을 담당할 인터페이스를 생성하고 행동을 정의한다.
                - 요청에 대한 쿼리 생성
                - 요청에 대한 페이징 쿼리 생성
            - MemberRequest<T> 
                - Member
                - T page()
                - T query()
            - MemberRequest 인터페이스로 레이어 간 메시지를 전송
            - 메소드 구현은 구현체에서 DB에 알맞는 타입으로 구현할 것
    - 비즈니스 흐름의 직관성과 유연성 둘 중 어떤 것을 더 가치를 둘 것인지?
        - 직관성에 가치를 둔다면, 해당 코드만 보고도 어떤 로직이 어디에 구현되어 있는지 파악이 될 수 있어야 함
        - 유연성에 가치를 둔다면, 이 부분은 좀 어려울 수 있음. 다만, 패키지나 애플리케이션 등의 책임에 대한 정보를 바탕으로 코드 구현 위치를 유추할 수 있게끔 구성하는 등 노력하는게 중요함.

    </details>
   

- 변경 대상이 되어야 하는 것
    1. A Controller <- 이건 내가 
    2. B Controller <- 이건 새로 들어올 인원 중 더 경력 많은 분에게
    3. C/D Controller <- 이건 그 다음 분에게
    4. 그 외에는 event / email / config 등은 패키지 구조 변경 정도가 될 수도? 
        - 이 부분은 여럿이서 함께 논의를 해야함

- 그리고 곧 퇴사할 전임자에게 이 부분에 대한 피드백을 지속적으로 받으며 각기 맡은 부분에 대한 코드 이해를 높여야 함
    - 아키텍처 회의에 매번 참여 부탁하는 건 당연하고 리팩토링에 대한 리뷰, 중간에 하면서 생길 질문을 받아달라고 요청이 필요함
    - 이렇게 해야 A 관련된 작업을 내가 추후 커버 하는데 문제가 없을 거고, 내가 작업한 B의 경우 다른 분한테 추가 수정사항이 생기는 것에 대해 일을 맡길 수 있고. C/D도 마찬가지임
    - 그리고 이 서버에서 히스토리가 가장 오래된 것도 A 쪽이고, B, C, D는 내가 들어온 이후 같이 진행 했기 때문에 내가 어느 정도 이해하고 있어서 크게 문제가 되지 않을 것임
    - 각각에게 B, C, D의 작업을 맡겨야 앞으로 A 작업을 내가 하면서 현재 새롭게 진행할 E 작업을 내가 맡아서 할 수 있음. 내가 모든 걸 대응할 수 없다. 
